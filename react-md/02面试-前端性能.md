## 前端加载优化

    性能优化的目的
    1.首屏时间
    2. 首次可交互时间

    做过哪些努力
    1. 只请求当前所需要的资源
        异步加载 懒加载
    - js放到最后，async defer
    - 防抖节流
    - 重绘回流
    2. 缩减资源体积
    3. 时序优化 promise  .all .any
    4. 合理利用缓存 (cdn),静态资源放cdn

## 是否关注过前端内存处理嘛

1.内存的生命周期

- 内存分配： 声明变量，函数等时，js 就会分配内存了
- 内存使用：调用时
- 内存回收：使用完毕，js 自己的回收机制，然后对其回收。

2. js 中的垃圾回收机制
   当你的内存使用后，根据 js 垃圾回收机制算法，判断你这块内存不在使用了，就把这块内存地址收回来

- 引用计数垃圾回收机制
  如果 a 对象对 b 对象有访问权限，那么成为 a 引用 b 对象。
  缺陷：循环引用的声明 是不会被清除的。 eg: a,b 互相引用。

- 标记清除算法
  1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
  2. 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
  3. 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
  4. 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收

3. js 中， 有哪些常见的内存泄露

   1. 全局变量 eg:window.a= 'xx';
   2. 未被清除的定时器和回调；
   3. 闭包
   4. dom 的引用

4. 如何避免内存泄露
   减少不必要的全局变量
   使用完数据后，及时解除引用

## 实现 sizeOf()函数

    传入一个参数object,计算这个object占用了多少bytes

- number: 8 个字节
- string: 2 个字节
- boolean:4 个字节

## 前端 http 请求相关

    1. 平时怎么解决跨越问题的

- jsonp 只支持 get
- cors 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 前端分为简单请求（get,head,post）和复杂请求
- node 正向代理 /api -> node -> api/ ->前端
- nginx 反向代理 proxy_pass

2. 有做过全局的处理嘛， 比如统一处理登陆态，统一处理全局错误
1. axios adaptar

1. 代码题， 你能给 xhr ,添加 hook ,实现在各个阶段打日志嘛
